# 前端面试知识点整理汇总  (持续更新中...)
人总要往前走，不能长时间停留在原地，所以当你觉得你一直处于某种停留的状态，那么，是时候去做一下事情来改变现状了，不如去学习吧，为了提升自己的专业能力，也为了让自己更加自信（更为了更高的薪水）！
学习付出的成本和代价是最低的，就像免费的东西永远是最贵的一样。

当然，在学习的过程中难免枯燥，但，学以致用能缓解这种枯燥，所以，碰到一个不常用/没见过的知识点，如果有实践条件，那么最好是动手去验证一下，这样就能将知识点赋予特定场景来加深印象，而不单单只是理论支撑。

在我们写代码的时候，可能知道是这么写，但是不知道为什么要这样写，这样写背后的原理是什么。这种只知其然，不知其所以然的状态的根源是对基础知识掌握薄弱所造成的。所以，如果想成为人们口中的大神，想对某段具体代码进行分析原理时侃侃而谈，想在代码出错时快速定位并解决问题，那么就好好静下心来学习基础知识吧。

---

## JavaScript
  - <a href="#js1">解释型动态语言（单线程）</a>
  - <a href="#js2">数据类型</a>
  - <a herf="#js3">作用域与作用域链</a>
  - <a href="#js4">提升</a>
  - <a href="#js5">闭包</a>

## CSS

## HTML

## HTTP

## 算法

## Webpack

## 性能优化

## 浏览器

## 安全

## 框架
- ### Vue
- ### React

## TypeScript

## NodeJs

---

### <span id='js1'>解释型动态语言（单线程）</span>
尽管通常将JavaScript归类为“动态”或”解释执行”语言，但事实上它是一门<b><font color='#DF402A'>编译语言</font></b>，它不是提前编译的，而是在代码执行前的几微秒（甚至更短）进行编译的。

程序中一段源代码在执行之前会经历三个步骤，统称为“编译”:
- 分词/词法分析
- 解析/语法分析
    这个过程是将词法单元流（数组）转换成一个<b><font color='#DF402A'>由元素逐级嵌套所组成的代表了程序语言结构的树</font></b> 。这个树被称为“<b><font color='#DF402A'>抽象语法树</font></b>”（Abstract Syntax Tree， <b><font color='#DF402A'>AST</font></b>）
- 代码生成
    将AST转换为可执行代码的过程被称为代码生成。

单线程：
- JavaScript开发出来是为了操作DOM元素，为了避免多线程同时操作同一DOM元素带来的各种问题，采用单线程。
- JavaScript是基于单线程运行的，同时又是可以异步运行的，一般来说这种即是单线程又是异步的语法都是基于事件来驱动的，恰好浏览器就给JavaScript提供了这么一个环境。  
  - 浏览器的常驻的线程：  
    - js引擎线程（解释执行js代码，用户输入、网络请求）
    - GUI线程（绘制用户界面，与JS主线程是互斥的）
    - http网络请求线程（处理用户的get、post等请求，等返回结果后将回调函数推入任务队列）
    - 定时触发器线程（setTimeout、setInterval等待时间结束后把执行函数推入任务队列中）
    - 浏览器事件处理线程（将click、mouse等交互事件发成后将这些事件放入任务队列中）

---

### <span id="js2">数据类型</span>
在JavaScript中一共有七种主要类型（术语是“语言类型”）  
&nbsp;&nbsp;&nbsp;&nbsp;简单基本类型（string、number、boolean、null、undefined、symbol【ES6中新增】）、object  

简单基本类型本身并不是对象。null有时会被当做一种对象类型，但是这其实只是语言本身的一个bug，即对null执行typeof null 时会返回字符串“object”。实际上，<b><font color='#DF402A'>null本身是基本类型</font></b> 。  

使用typeof 能判断的类型分别为：  
&nbsp;&nbsp;&nbsp;&nbsp;除null以外的基本数据类型、function

---

### <span id="js3">作用域与作用域链</span>
通常来说，一段程序代码中使用的变量和函数并不总是可用的，<b><font color='#DF402A'>限定其可用性的范围即作用域链</font></b>，作用域的使用<b><font color='#DF402A'>提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突</font></b> 。  

当一个块或函数嵌套在另一个块或函数中，就发生了作用域的嵌套；也就是说函数、块才能形成一个作用域。  

ES6之前的作用域一般来说就只有函数作用域，几乎没有块作用域，除了try{}catch(){} 中catch块。

作用域链：  
&nbsp;&nbsp;&nbsp;&nbsp;作用域链决定了哪些数据能被函数访问，当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。

作用域规则在解释/编译阶段被确定；  
作用域链在执行阶段被确认，是执行上下文的一部分。  

JavaScript编译阶段便会确定作用域规则，因此<b><font color='#DF402A'>作用域在函数定义时就已经确定了</font></b>，而不是在函数调用时确定；但是执行上下文是函数执行之前创建的。  

<b><font color='#DF402A'>执行上下文</font></b>最明显的就是this的指向是执行时确定的，而作用域访问的变量是编写代码结构时确定的。  

作用域和执行上下文之间最大的区别是：  
&nbsp;&nbsp;&nbsp;&nbsp;执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。  

执行上下文包括：<b><font color='#DF402A'>对象变量、作用域链、this指向</font></b> 。  

同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量值。

---

### <span id="js4">提升</span>
无论作用域中的声明（ES6中的let、const定义的块作用域变量不会发生提升行为）出现在什么地方，都将在代码本身被执行前首先进行处理，可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。  

``` var a = 2 ```，你可能会认为是一个声明，但JavaScript实际上会将其看成两个声明；``` var a; ``` 和 ```a = 2; ```。第一个定义声明是在编译阶段进行的，第二个赋值声明会被留在原地等待执行阶段。  

函数声明也会被提升，但是函数表达式却不会被提升。（函数声明：```function func(){}```。 函数表达式 ```var func = function(){}``` )。   

<b><font color='#DF402A'>函数优先</font></b>：函数声明和变量声明（var）都会被提升。但是一个值得注意的一节是函数会首先被提升，然后才是变量。  

<b><font color='#DF402A'>声明本身会被提升</font></b>，而包括函数表达式的赋值在内的赋值操作并不会提升。

---

### <span id="js5">闭包</span>
闭包的定义：  
&nbsp;&nbsp;&nbsp;&nbsp;当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。  

怎么形成闭包：  
&nbsp;&nbsp;&nbsp;&nbsp;1、必须有外部的封闭函数，且内部函数访问了外部函数中的变量。  
&nbsp;&nbsp;&nbsp;&nbsp;2、返回这个内层函数/将该内层函数挂载在通过window能够访问到的对象上。（这样外部才有可能访问和执行这个返回的内层函数）  

闭包可以阻止引擎的垃圾回收器对外部封闭函数进行回收。是因为内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域，是内层函数在使用。  

内层函数依然持有对该作用域的引用，而这个引用就叫做闭包。  

在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或同步）任务中，只要使用了回调函数，实际上就是在使用闭包！

[importantColor]: #DF402A
